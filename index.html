<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>CHU Portfolio — Smooth Scroll + Sticky Value</title>
    <link rel="stylesheet" href="style.css" />
    <!-- Updated Three.js imports to use proper ES modules -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <nav class="nav">
      <a href="#hero">TOP</a>
      <a href="#concept">CONCEPT</a>
      <a href="#value">VALUE</a>
      <a href="#sticky-value">EXPERIENCE</a>
      <!-- Added navigation link to point cloud section -->
      <a href="#pointcloud">3D DEMO</a>
    </nav>

    <!-- HERO -->
    <header id="hero" class="hero">
      <!-- Added 3D point cloud canvas as background -->
      <canvas id="hero-pointcloud" class="hero__background"></canvas>
      
      <div class="hero__top-left reveal">
        Designing clear experiences<br />from idea to delivery.
      </div>
      <h5 class="hero__title stretch">
  <span class="no-break sakiii-effect">Sakiii CHU</span><br />
  Portfolio
</h5>

      <address class="hero__bottom-left">
        Taipei, Taiwan<br />E-mail : tingccc93@gmail.com<br />GitHub :
        https://github.com/SakiiiCHU
      </address>
      <div class="hero__bottom-right">Scroll Down</div>
    </header>

    <!-- CONCEPT -->
    <section id="concept" class="concept">
      <div class="concept__wrap">
        <div class="eyebrow reveal">BUSINESS CONCEPT</div>
        <p class="concept__jp reveal">
          想いが生まれたその瞬間から、ユーザーに届く体験へ。設計から実装までを一気通貫で支援し、<br />シンプルで誠実、使いやすさを起点に価値を育てます。
        </p>
        <div class="concept__headline">
          <!-- Replaced slide animation with WOWGOW-style letter-by-letter animation -->
          <h2 class="slide-text">
            <span>Designs with</span>
            <span>Purpose</span>
          </h2>
        </div>
        <div class="concept__marquee marquee">
          ARCHITECTURE • INTERACTION • 3D VISUALIZATION • INTERFACE • COLOR •
        </div>
      </div>
    </section>

    <!-- VALUE -->
    <section id="value" class="value">
      <div class="value__head">
        <h3 class="reveal">Our Value</h3>
        <p class="reveal" style="max-width: 560px; color: var(--muted)">
          ビジュアルとロジックの橋渡し。要件の解像度を上げ、正しく設計し、最後まで作り切る。
        </p>
      </div>
      <div class="value__grid">
        <article class="value__card reveal">
          <div class="value__no">(01)</div>
          <h4 class="value__title">Spatial Thinking</h4>
          <p class="value__desc">
            空間情報、動線分析、構造把握など。測量や建築的な視点で情報を整理し、画面構成に落とし込む。
          </p>
        </article>
        <article class="value__card reveal">
          <div class="value__no">(02)</div>
          <h4 class="value__title">Interaction & Flow</h4>
          <p class="value__desc">
            スクロール、視線、操作感。動きすぎず、止まりすぎない。リズムのあるUIを目指す。
          </p>
        </article>
        <article class="value__card reveal">
          <div class="value__no">(03)</div>
          <h4 class="value__title">Handcrafted Interfaces</h4>
          <p class="value__desc">
            HTML/CSSをベースに、構造・意味・可読性を意識したコードで実装。過剰な演出より、静かで気持ちの良い使いやすさを大切にする。
          </p>
        </article>
      </div>
    </section>

    <!-- STICKY VALUE SECTION -->
    <section id="sticky-value" class="sticky-value">
      <div class="value__grid--sticky container">
        <!-- 左側：EXPERIENCE 標題 + 照片，一起 sticky 在左上 -->
        <aside class="value__left">
          <!-- <h2 class="experience__title stretch">EXPERIENCE</h2> -->
          <h2 class="experience__title experience-animated">
            <span>E</span><span>X</span><span>P</span><span>E</span
            ><span>R</span><span>I</span><span>E</span><span>N</span
            ><span>C</span><span>E</span>
          </h2>

          <div
            class="circle"
            style="
              background-image: url('img/img-profile.jpg');
              background-size: cover;
              background-position: center;
            "
            aria-label="profile"
          >
            <div class="circle__inner"></div>
          </div>
        </aside>

        <!-- 右側：可長內容，正常與整頁同一個捲動 -->
        <div class="value__right">
          <!-- EXPERIENCE SECTION -->
          <article class="value__item">
            <span style="font-size: 13px; color: #888">Sep. 2014 – Present</span
            ><br />
            <h2 class="value__title">
              Technical Consultant /<br />Research Assistant
            </h2>
            <p class="value__desc">
              <strong>Part-Time Project</strong><br />
              （非常勤プロジェクト）<br />
              • DSM and Building Reconstruction by UAV and Multi-View Images.<br />
              • Applications of Augmented Reality.<br />
              • Super Resolution Method for 3D Lidar Point Cloud Generation.<br />
              • Thermal Transmittance Analysis for Opaque Building Envelope.
            </p>
          </article>

          <article class="value__item">
            <span style="font-size: 13px; color: #888"
              >Apr. 2020 – Dec. 2020</span
            ><br />
            <h2 class="value__title">Assistant Researcher</h2>
            <p class="value__desc">
              <strong
                >Department of Land and Administration, Ministry of the Interior
                (MOI)</strong
              ><br />
              （内政部 土地管理局）<br />
              • Processing spatial data to analyze offshore events and create
              high-resolution maps.<br />
              • Processing multi-source point cloud data.
            </p>
          </article>

          <article class="value__item">
            <span style="font-size: 13px; color: #888"
              >Sep. 2018 – Dec. 2018</span
            ><br />
            <h2 class="value__title">
              Research Assistant<br />(Construction Engineering and Management)
            </h2>
            <p class="value__desc">
              <strong
                >Department of Civil Engineering, National Taiwan University
                (NTU)</strong
              ><br />
              （国立台湾大学 土木工学科）<br />
              • Green and Sustainable Smart Building: enhancing comfort while
              reducing energy use.<br />
              • Developing Model Predictive Control (MPC) algorithms and
              occupant-centered building management systems.
            </p>
          </article>

          <!-- EDUCATION SECTION -->
          <article class="value__item">
            <div class="value__kicker">EDUCATION / 学歴</div>
            <span style="font-size: 13px; color: #888">Sep. 2023 – Present</span
            ><br />
            <h2 class="value__title">Doctoral Degree Program</h2>
            <p class="value__desc">
              <strong
                >Tokyo Institute of Technology (now Institute of Science
                Tokyo)</strong
              ><br />
              （東京工業大学 → 現・東京科学大学 建築学系）<br />
              Tokyo, Japan
            </p>
          </article>

          <article class="value__item">
            <span style="font-size: 13px; color: #888"
              >Sep. 2016 – Jul. 2018</span
            ><br />
            <h2 class="value__title">Master of Science</h2>
            <p class="value__desc">
              <strong>National Taiwan University (NTU)</strong><br />
              （国立台湾大学 土木工学科）<br />
              Taipei, Taiwan
            </p>
          </article>

          <article class="value__item">
            <span style="font-size: 13px; color: #888"
              >Sep. 2012 – Jun. 2016</span
            ><br />
            <h2 class="value__title">Bachelor of Arts</h2>
            <p class="value__desc">
              <strong>National Taipei University (NTPU)</strong><br />
              （国立台北大学 不動産・建築環境学科）<br />
              Taipei, Taiwan
            </p>
          </article>
        </div>
      </div>
    </section>

    <!-- JS start from here -->
    <script>
      const cards = document.querySelectorAll(".value__item")

function updateXPosition() {
  if (window.innerWidth <= 480) {
    cards.forEach((card) => {
      card.style.transform = "translateX(0)"
    })
    return
  }

  const centerY = window.innerHeight / 2

  cards.forEach((card) => {
    const rect = card.getBoundingClientRect()
    const cardCenterY = rect.top + rect.height / 2
    const distance = Math.abs(centerY - cardCenterY)

    const maxOffset = 60
    const maxDistance = window.innerHeight / 2
    const ratio = Math.min(distance / maxDistance, 1)

    const offsetX = ratio * maxOffset
    const scale = 1 + (1 - ratio) * 0.1 // Center card slightly larger
    const opacity = 0.7 + (1 - ratio) * 0.3 // Center card more opaque

    card.style.transform = `translateX(${offsetX}px) scale(${scale})`
    card.style.opacity = opacity
  })
}

let ticking = false
function requestTick() {
  if (!ticking) {
    requestAnimationFrame(updateXPosition)
    ticking = true
    setTimeout(() => {
      ticking = false
    }, 16)
  }
}

window.addEventListener("scroll", requestTick)
window.addEventListener("resize", updateXPosition)
updateXPosition();

    </script>
    <script>
      const experienceTitle = document.querySelector(".experience-animated");
      const spans = experienceTitle.querySelectorAll("span");

      // 設定一開始亂飛的方向
      spans.forEach((span, i) => {
        const angle = Math.random() * 360;
        const distance = 100 + Math.random() * 200;
        const dx = Math.cos(angle) * distance;
        const dy = Math.sin(angle) * distance;
        const r = Math.random() * 360 - 180;
        span.style.setProperty("--dx", `${dx}px`);
        span.style.setProperty("--dy", `${dy}px`);
        span.style.setProperty("--r", `${r}deg`);
      });

      // Intersection Observer：進入畫面時觸發 in-view
      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              experienceTitle.classList.add("in-view");
            }
          });
        },
        {
          threshold: 0.2,
        }
      );

      observer.observe(experienceTitle);

      // 滾動到一定位置後吸附左上角
      window.addEventListener("scroll", () => {
        const stickyTrigger = experienceTitle.getBoundingClientRect().top;
        if (stickyTrigger <= 50) {
          experienceTitle.classList.add("sticky");
        } else {
          experienceTitle.classList.remove("sticky");
        }
      });
    </script>
    <script>
      // 1) 停用瀏覽器的自動卷軸還原
      if ("scrollRestoration" in history) {
        history.scrollRestoration = "manual";
      }
    
      // 2) 載入時，如果網址有 #hash，清掉並回到最上方
      window.addEventListener("load", () => {
        if (location.hash) {
          history.replaceState(null, "", location.pathname + location.search);
        }
        // 兩幀後再滾到頂，確保排版完成
        requestAnimationFrame(() => {
          requestAnimationFrame(() => window.scrollTo(0, 0));
        });
      });
    
      // 3) 攔截所有指向 #id 的連結，改用 JS 平滑捲動，且不改網址
      document.addEventListener("click", (e) => {
        const a = e.target.closest('a[href^="#"]');
        if (!a) return;
        const id = a.getAttribute("href");
        if (id.length <= 1) return; // 跳過 href="#" 之類
        const el = document.querySelector(id);
        if (!el) return;
        e.preventDefault();
        el.scrollIntoView({ behavior: "smooth", block: "start" });
        // 清掉 hash，避免重新整理又跳
        history.replaceState(null, "", location.pathname + location.search);
      });
    </script>
    <script>
      document.addEventListener('DOMContentLoaded', function () {
        const headers = document.querySelectorAll('.slide-text');
        if (!headers.length) return;

        const io = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            const el = entry.target;
            if (entry.isIntersecting) {
              el.classList.add('is-in');
              el.classList.remove('is-out');
            } else {
              el.classList.remove('is-in');
              el.classList.add('is-out');
            }
          });
        }, { threshold: 0.35 });

        headers.forEach(h => io.observe(h));

        // Exit animation when leaving page
        const leaveAll = () => headers.forEach(h => h.classList.add('leaving'));
        window.addEventListener('pagehide', leaveAll);
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'hidden') {
            leaveAll();
          }
        });
      });
    </script>
    <!-- Updated Three.js script with better error handling and debugging -->
    <script type="module">
      import * as THREE from 'three';

      class PointCloudEffect {
        constructor() {
          this.scene = null;
          this.camera = null;
          this.renderer = null;
          this.pointClouds = []; // Array to hold multiple point clouds
          this.originalPositions = [];
          this.targetPositions = [];
          this.animationProgress = 0;
          this.isAnimating = false;
          this.animationStartTime = 0;
          this.isInitialized = false;
          this.animationId = null;
          this.animationPhase = 0;
          this.particleDelays = [];
          this.originalColors = [];
          this.targetColors = [];
          
          this.init();
          this.setupPageVisibilityHandling();
        }

        setupPageVisibilityHandling() {
          const cleanup = () => {
            if (this.animationId) {
              cancelAnimationFrame(this.animationId);
            }
            this.pointClouds.forEach(pointCloud => {
              if (pointCloud.geometry) {
                pointCloud.geometry.dispose();
              }
              if (pointCloud.material) {
                pointCloud.material.dispose();
              }
              if (this.scene) {
                this.scene.remove(pointCloud);
              }
            });
            if (this.renderer) {
              this.renderer.dispose();
              this.renderer.forceContextLoss();
            }
          };

          window.addEventListener('beforeunload', cleanup);
          window.addEventListener('pagehide', cleanup);
          
          document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
              if (!this.isInitialized || !this.renderer || this.renderer.getContext().isContextLost()) {
                this.reinitialize();
              } else {
                this.resumeAnimation();
              }
            } else {
              this.pauseAnimation();
            }
          });

          const canvas = document.getElementById('hero-pointcloud');
          if (canvas) {
            canvas.addEventListener('webglcontextlost', (event) => {
              event.preventDefault();
              this.pauseAnimation();
            });

            canvas.addEventListener('webglcontextrestored', () => {
              this.reinitialize();
            });
          }
        }

        pauseAnimation() {
          if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
          }
        }

        resumeAnimation() {
          if (!this.animationId && this.isInitialized) {
            this.animate();
          }
        }

        reinitialize() {
          this.isInitialized = false;
          
          this.pointClouds.forEach(pointCloud => {
            if (this.scene) {
              this.scene.remove(pointCloud);
            }
          });
          this.pointClouds = [];
          
          this.init();
        }

        init() {
          const canvas = document.getElementById('hero-pointcloud');
          if (!canvas) {
            console.error('Canvas element not found');
            return;
          }
          
          this.scene = new THREE.Scene();
          this.scene.background = null;
          
          this.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 1000);
          this.camera.position.set(0, 2, 8);
          this.camera.lookAt(0, 0, 0);
          
          this.renderer = new THREE.WebGLRenderer({ 
            canvas: canvas, 
            antialias: true,
            alpha: true
          });
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          this.renderer.setClearColor(0x000000, 0);
          
          const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
          this.scene.add(ambientLight);
          
          const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
          directionalLight1.position.set(5, 5, 5);
          this.scene.add(directionalLight1);
          
          this.loadBINFile();
          
          this.setupControls();
          window.addEventListener('resize', () => this.onWindowResize());
          this.animate();
          this.isInitialized = true;
        }

        loadBINFile() {
          const loadFile1 = fetch('./linkou_1.bin').then(response => {
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            return response.arrayBuffer();
          });
          
          const loadFile2 = fetch('./linkou_2.bin').then(response => {
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            return response.arrayBuffer();
          });
          
          Promise.all([loadFile1, loadFile2])
            .then(([buffer1, buffer2]) => {
              this.parseDualBinaryPointClouds(buffer1, buffer2);
            })
            .catch(error => {
              console.warn('Dual BIN load failed:', error);
              // Fallback to single file
              fetch('./linkou_1.bin')
                .then(response => response.arrayBuffer())
                .then(buffer => this.parseBinaryPointCloud(buffer))
                .catch(() => {
                  this.createFallbackParticles();
                });
            });
        }

        parseDualBinaryPointClouds(buffer1, buffer2) {
          const pointSize = 15; // 12 bytes float + 3 bytes color
          const numPoints1 = Math.floor(buffer1.byteLength / pointSize);
          const numPoints2 = Math.floor(buffer2.byteLength / pointSize);
          const totalPoints = numPoints1 + numPoints2;
          
          if (totalPoints === 0) {
            console.warn('No valid points found in binary data');
            this.createFallbackParticles();
            return;
          }
          
          const positions = new Float32Array(totalPoints * 3);
          const colors = new Float32Array(totalPoints * 3);
          
          // Parse first file
          const dv1 = new DataView(buffer1);
          for (let i = 0; i < numPoints1; i++) {
            const offset = i * pointSize;
            const x = dv1.getFloat32(offset, true);
            const y = dv1.getFloat32(offset + 4, true);
            const z = dv1.getFloat32(offset + 8, true);
            const r = dv1.getUint8(offset + 12);
            const g = dv1.getUint8(offset + 13);
            const b = dv1.getUint8(offset + 14);
            
            positions.set([x, y, z], i * 3);
            colors.set([r / 255, g / 255, b / 255], i * 3);
          }
          
          // Parse second file
          const dv2 = new DataView(buffer2);
          for (let i = 0; i < numPoints2; i++) {
            const offset = i * pointSize;
            const x = dv2.getFloat32(offset, true);
            const y = dv2.getFloat32(offset + 4, true);
            const z = dv2.getFloat32(offset + 8, true);
            const r = dv2.getUint8(offset + 12);
            const g = dv2.getUint8(offset + 13);
            const b = dv2.getUint8(offset + 14);
            
            const targetIndex = (numPoints1 + i) * 3;
            positions.set([x, y, z], targetIndex);
            colors.set([r / 255, g / 255, b / 255], targetIndex);
          }
          
          // Create combined geometry
          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
          
          this.createParticleSystem(geometry);
        }

        parseBinaryPointCloud(buffer) {
          // Existing code for parsing single binary point cloud
        }

        createParticleSystem(geometry) {
          const material = new THREE.PointsMaterial({
            size: 0.03,
            vertexColors: true,
            transparent: true,
            opacity: 0.9,
            sizeAttenuation: true,
          });

          geometry.computeBoundingBox();
          const box = geometry.boundingBox;
          
          const center = new THREE.Vector3();
          box.getCenter(center);

          geometry.translate(-center.x, -center.y, -center.z);

          const size = new THREE.Vector3();
          box.getSize(size);
          const maxDim = Math.max(size.x, size.y, size.z);
          const scale = 12 / maxDim;
          geometry.scale(scale, scale, scale);

          const positions = geometry.attributes.position.array;
          const colors = geometry.attributes.color.array;
          const particleCount = positions.length / 3;
          
          this.targetPositions = [];
          this.targetColors = [];
          for (let i = 0; i < particleCount; i++) {
            const x = positions[i * 3];
            const y = positions[i * 3 + 1];
            const z = positions[i * 3 + 2];
            
            this.targetPositions.push(x, z, y);
            
            this.targetColors.push(
              colors[i * 3],
              colors[i * 3 + 1], 
              colors[i * 3 + 2]
            );
          }
          
          this.createInitialPatterns(particleCount);
          
          geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.originalPositions), 3));
          geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(this.originalColors), 3));
          
          const pointCloud = new THREE.Points(geometry, material);
          this.pointClouds.push(pointCloud);
          this.scene.add(pointCloud);
          
          this.startAnimation();
        }

        createInitialPatterns(particleCount) {
          this.originalPositions = [];
          this.originalColors = [];
          this.particleDelays = [];
          
          for (let i = 0; i < particleCount; i++) {
            const radius = 4 + Math.random() * 8;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            
            this.originalPositions.push(
              radius * Math.sin(phi) * Math.cos(theta),
              radius * Math.sin(phi) * Math.sin(theta),
              radius * Math.cos(phi)
            );
            
            this.originalColors.push(
              0.1 + Math.random() * 0.2, // Very dim colors for background effect
              0.2 + Math.random() * 0.3,
              0.3 + Math.random() * 0.4
            );
            
            this.particleDelays.push(Math.random() * 0.5);
          }
        }

        createFallbackParticles() {
          const particleCount = 2000;
          
          // Create target positions in sphere formation
          this.targetPositions = [];
          this.targetColors = [];
          for (let i = 0; i < particleCount; i++) {
            const radius = 6 + Math.random() * 2;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            
            this.targetPositions.push(
              radius * Math.sin(phi) * Math.cos(theta),
              radius * Math.sin(phi) * Math.sin(theta),
              radius * Math.cos(phi)
            );
            
            // Rainbow colors for fallback
            const hue = (i / particleCount) * 360;
            const color = new THREE.Color().setHSL(hue / 360, 0.8, 0.6);
            this.targetColors.push(color.r, color.g, color.b);
          }
          
          this.createInitialPatterns(particleCount);
          
          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(this.originalPositions), 3));
          geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(this.originalColors), 3));
          
          const material = new THREE.PointsMaterial({
            size: 0.05,
            vertexColors: true,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.9
          });
          
          const pointCloud = new THREE.Points(geometry, material);
          this.pointClouds.push(pointCloud);
          this.scene.add(pointCloud);
          
          this.startAnimation();
        }

        startAnimation() {
          this.isAnimating = true;
          this.animationStartTime = Date.now();
        }

        setupControls() {
          let mouseX = 0, mouseY = 0;
          let targetRotationX = 0, targetRotationY = 0;
          
          document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX - window.innerWidth / 2) / window.innerWidth;
            mouseY = (event.clientY - window.innerHeight / 2) / window.innerHeight;
            
            targetRotationX = mouseY * 0.2;
            targetRotationY = mouseX * 0.2;
          });
          
          const updateRotation = () => {
            this.pointClouds.forEach(pointCloud => {
              if (pointCloud) {
                pointCloud.rotation.x += (targetRotationX - pointCloud.rotation.x) * 0.05;
                pointCloud.rotation.y += (targetRotationY - pointCloud.rotation.y) * 0.05;
              }
            });
            requestAnimationFrame(updateRotation);
          };
          updateRotation();
        }

        animate() {
          this.animationId = requestAnimationFrame(() => this.animate());
          
          const mainPointCloud = this.pointClouds[0];
          
          if (this.isAnimating && mainPointCloud) {
            const elapsed = Date.now() - this.animationStartTime;
            const totalDuration = 4000;
            this.animationProgress = Math.min(elapsed / totalDuration, 1);
            
            this.updateParticlePositions(this.animationProgress);
            this.updateParticleColors(this.animationProgress);
            
            if (this.animationProgress >= 1) {
              this.isAnimating = false;
            }
          }
          
          if (!this.isAnimating && mainPointCloud) {
            const time = Date.now() * 0.001;
            mainPointCloud.rotation.y += 0.003;
            
            const breathe = 1 + Math.sin(time * 0.5) * 0.02;
            mainPointCloud.scale.setScalar(breathe);
            
            if (mainPointCloud.material) {
              mainPointCloud.material.opacity = 0.85 + Math.sin(time * 0.8) * 0.1;
            }
          }
          
          this.renderer.render(this.scene, this.camera);
        }

        updateParticlePositions(progress) {
          const mainPointCloud = this.pointClouds[0];
          if (!mainPointCloud) return;
          
          const currentPositions = [];
          const particleCount = this.originalPositions.length / 3;
          
          for (let i = 0; i < particleCount; i++) {
            const delay = this.particleDelays[i];
            const adjustedProgress = Math.max(0, Math.min(1, (progress - delay) / (1 - delay)));
            
            const easing = 1 - Math.pow(1 - adjustedProgress, 2);
            
            currentPositions.push(
              this.originalPositions[i * 3] + (this.targetPositions[i * 3] - this.originalPositions[i * 3]) * easing,
              this.originalPositions[i * 3 + 1] + (this.targetPositions[i * 3 + 1] - this.originalPositions[i * 3 + 1]) * easing,
              this.originalPositions[i * 3 + 2] + (this.targetPositions[i * 3 + 2] - this.originalPositions[i * 3 + 2]) * easing
            );
          }
          
          mainPointCloud.geometry.setAttribute('position', 
            new THREE.Float32BufferAttribute(currentPositions, 3));
          mainPointCloud.geometry.attributes.position.needsUpdate = true;
        }

        updateParticleColors(progress) {
          const mainPointCloud = this.pointClouds[0];
          if (!mainPointCloud) return;
          
          const currentColors = [];
          const particleCount = this.originalColors.length / 3;
          
          for (let i = 0; i < particleCount; i++) {
            const colorProgress = Math.min(1, progress * 1.2);
            
            currentColors.push(
              this.originalColors[i * 3] + (this.targetColors[i * 3] - this.originalColors[i * 3]) * colorProgress,
              this.originalColors[i * 3 + 1] + (this.targetColors[i * 3 + 1] - this.originalColors[i * 3 + 1]) * colorProgress,
              this.originalColors[i * 3 + 2] + (this.targetColors[i * 3 + 2] - this.originalColors[i * 3 + 2]) * colorProgress
            );
          }
          
          mainPointCloud.geometry.setAttribute('color', 
            new THREE.Float32BufferAttribute(currentColors, 3));
          mainPointCloud.geometry.attributes.color.needsUpdate = true;
        }

        onWindowResize() {
          this.camera.aspect = window.innerWidth / window.innerHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(window.innerWidth, window.innerHeight);
        }
      }

      document.addEventListener('DOMContentLoaded', () => {
        try {
          new PointCloudEffect();
        } catch (error) {
          console.error('Failed to initialize dual point cloud:', error);
        }
      });
    </script>
  </body>
</html>
