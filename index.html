<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>CHU Portfolio — Smooth Scroll + Sticky Value</title>
    <link rel="stylesheet" href="style.css" />
    <!-- Updated Three.js imports to use proper ES modules -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <nav class="nav">
      <a href="#hero">TOP</a>
      <a href="#concept">CONCEPT</a>
      <a href="#value">VALUE</a>
      <a href="#sticky-value">EXPERIENCE</a>
      <!-- Added navigation link to point cloud section -->
      <a href="#pointcloud">3D DEMO</a>
    </nav>

    <!-- HERO -->
    <header id="hero" class="hero">
      <!-- Added 3D point cloud canvas as background -->
      <canvas id="hero-pointcloud" class="hero__background"></canvas>
      
      <div class="hero__top-left reveal">
        Designing clear experiences<br />from idea to delivery.
      </div>
      <h5 class="hero__title stretch">
  <span class="no-break sakiii-effect">Sakiii CHU</span><br />
  Portfolio
</h5>

      <address class="hero__bottom-left">
        Taipei, Taiwan<br />E-mail : tingccc93@gmail.com<br />GitHub :
        https://github.com/SakiiiCHU
      </address>
      <div class="hero__bottom-right">Scroll Down</div>
    </header>

    <!-- CONCEPT -->
    <section id="concept" class="concept">
      <div class="concept__wrap">
        <div class="eyebrow reveal">BUSINESS CONCEPT</div>
        <p class="concept__jp reveal">
          想いが生まれたその瞬間から、ユーザーに届く体験へ。設計から実装までを一気通貫で支援し、<br />シンプルで誠実、使いやすさを起点に価値を育てます。
        </p>
        <div class="concept__headline">
          <!-- Replaced slide animation with WOWGOW-style letter-by-letter animation -->
          <h2 class="slide-text">
            <span>Designs with</span>
            <span>Purpose</span>
          </h2>
        </div>
        <div class="concept__marquee marquee">
          ARCHITECTURE • INTERACTION • 3D VISUALIZATION • INTERFACE • COLOR •
        </div>
      </div>
    </section>

    <!-- VALUE -->
    <section id="value" class="value">
      <div class="value__head">
        <h3 class="reveal">Our Value</h3>
        <p class="reveal" style="max-width: 560px; color: var(--muted)">
          ビジュアルとロジックの橋渡し。要件の解像度を上げ、正しく設計し、最後まで作り切る。
        </p>
      </div>
      <div class="value__grid">
        <article class="value__card reveal">
          <div class="value__no">(01)</div>
          <h4 class="value__title">Spatial Thinking</h4>
          <p class="value__desc">
            空間情報、動線分析、構造把握など。測量や建築的な視点で情報を整理し、画面構成に落とし込む。
          </p>
        </article>
        <article class="value__card reveal">
          <div class="value__no">(02)</div>
          <h4 class="value__title">Interaction & Flow</h4>
          <p class="value__desc">
            スクロール、視線、操作感。動きすぎず、止まりすぎない。リズムのあるUIを目指す。
          </p>
        </article>
        <article class="value__card reveal">
          <div class="value__no">(03)</div>
          <h4 class="value__title">Handcrafted Interfaces</h4>
          <p class="value__desc">
            HTML/CSSをベースに、構造・意味・可読性を意識したコードで実装。過剰な演出より、静かで気持ちの良い使いやすさを大切にする。
          </p>
        </article>
      </div>
    </section>

    <!-- STICKY VALUE SECTION -->
    <section id="sticky-value" class="sticky-value">
      <div class="value__grid--sticky container">
        <!-- 左側：EXPERIENCE 標題 + 照片，一起 sticky 在左上 -->
        <aside class="value__left">
          <!-- <h2 class="experience__title stretch">EXPERIENCE</h2> -->
          <h2 class="experience__title experience-animated">
            <span>E</span><span>X</span><span>P</span><span>E</span
            ><span>R</span><span>I</span><span>E</span><span>N</span
            ><span>C</span><span>E</span>
          </h2>

          <div
            class="circle"
            style="
              background-image: url('img/img-profile.png');
              background-size: cover;
              background-position: center;
            "
            aria-label="profile"
          >
            <div class="circle__inner"></div>
          </div>
        </aside>

        <!-- 右側：可長內容，正常與整頁同一個捲動 -->
        <div class="value__right">
          <!-- EXPERIENCE SECTION -->
          <article class="value__item">
            <span style="font-size: 13px; color: #888">Sep. 2014 – Present</span
            ><br />
            <h2 class="value__title">
              Technical Consultant /<br />Research Assistant
            </h2>
            <p class="value__desc">
              <strong>Part-Time Project</strong><br />
              （非常勤プロジェクト）<br />
              • DSM and Building Reconstruction by UAV and Multi-View Images.<br />
              • Applications of Augmented Reality.<br />
              • Super Resolution Method for 3D Lidar Point Cloud Generation.<br />
              • Thermal Transmittance Analysis for Opaque Building Envelope.
            </p>
          </article>

          <article class="value__item">
            <span style="font-size: 13px; color: #888"
              >Apr. 2020 – Dec. 2020</span
            ><br />
            <h2 class="value__title">Assistant Researcher</h2>
            <p class="value__desc">
              <strong
                >Department of Land and Administration, Ministry of the Interior
                (MOI)</strong
              ><br />
              （内政部 土地管理局）<br />
              • Processing spatial data to analyze offshore events and create
              high-resolution maps.<br />
              • Processing multi-source point cloud data.
            </p>
          </article>

          <article class="value__item">
            <span style="font-size: 13px; color: #888"
              >Sep. 2018 – Dec. 2018</span
            ><br />
            <h2 class="value__title">
              Research Assistant<br />(Construction Engineering and Management)
            </h2>
            <p class="value__desc">
              <strong
                >Department of Civil Engineering, National Taiwan University
                (NTU)</strong
              ><br />
              （国立台湾大学 土木工学科）<br />
              • Green and Sustainable Smart Building: enhancing comfort while
              reducing energy use.<br />
              • Developing Model Predictive Control (MPC) algorithms and
              occupant-centered building management systems.
            </p>
          </article>

          <!-- EDUCATION SECTION -->
          <article class="value__item">
            <div class="value__kicker">EDUCATION / 学歴</div>
            <span style="font-size: 13px; color: #888">Sep. 2023 – Present</span
            ><br />
            <h2 class="value__title">Doctoral Degree Program</h2>
            <p class="value__desc">
              <strong
                >Tokyo Institute of Technology (now Institute of Science
                Tokyo)</strong
              ><br />
              （東京工業大学 → 現・東京科学大学 建築学系）<br />
              Tokyo, Japan
            </p>
          </article>

          <article class="value__item">
            <span style="font-size: 13px; color: #888"
              >Sep. 2016 – Jul. 2018</span
            ><br />
            <h2 class="value__title">Master of Science</h2>
            <p class="value__desc">
              <strong>National Taiwan University (NTU)</strong><br />
              （国立台湾大学 土木工学科）<br />
              Taipei, Taiwan
            </p>
          </article>

          <article class="value__item">
            <span style="font-size: 13px; color: #888"
              >Sep. 2012 – Jun. 2016</span
            ><br />
            <h2 class="value__title">Bachelor of Arts</h2>
            <p class="value__desc">
              <strong>National Taipei University (NTPU)</strong><br />
              （国立台北大学 不動産・建築環境学科）<br />
              Taipei, Taiwan
            </p>
          </article>
        </div>
      </div>
    </section>

    <!-- JS start from here -->
    <script>
      const cards = document.querySelectorAll(".value__item")

function updateXPosition() {
  if (window.innerWidth <= 480) {
    cards.forEach((card) => {
      card.style.transform = "translateX(0)"
    })
    return
  }

  const centerY = window.innerHeight / 2

  cards.forEach((card) => {
    const rect = card.getBoundingClientRect()
    const cardCenterY = rect.top + rect.height / 2
    const distance = Math.abs(centerY - cardCenterY)

    const maxOffset = 60
    const maxDistance = window.innerHeight / 2
    const ratio = Math.min(distance / maxDistance, 1)

    const offsetX = ratio * maxOffset
    const scale = 1 + (1 - ratio) * 0.1 // Center card slightly larger
    const opacity = 0.7 + (1 - ratio) * 0.3 // Center card more opaque

    card.style.transform = `translateX(${offsetX}px) scale(${scale})`
    card.style.opacity = opacity
  })
}

let ticking = false
function requestTick() {
  if (!ticking) {
    requestAnimationFrame(updateXPosition)
    ticking = true
    setTimeout(() => {
      ticking = false
    }, 16)
  }
}

window.addEventListener("scroll", requestTick)
window.addEventListener("resize", updateXPosition)
updateXPosition();

    </script>
    <script>
      const experienceTitle = document.querySelector(".experience-animated");
      const spans = experienceTitle.querySelectorAll("span");

      // 設定一開始亂飛的方向
      spans.forEach((span, i) => {
        const angle = Math.random() * 360;
        const distance = 100 + Math.random() * 200;
        const dx = Math.cos(angle) * distance;
        const dy = Math.sin(angle) * distance;
        const r = Math.random() * 360 - 180;
        span.style.setProperty("--dx", `${dx}px`);
        span.style.setProperty("--dy", `${dy}px`);
        span.style.setProperty("--r", `${r}deg`);
      });

      // Intersection Observer：進入畫面時觸發 in-view
      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              experienceTitle.classList.add("in-view");
            }
          });
        },
        {
          threshold: 0.2,
        }
      );

      observer.observe(experienceTitle);

      // 滾動到一定位置後吸附左上角
      window.addEventListener("scroll", () => {
        const stickyTrigger = experienceTitle.getBoundingClientRect().top;
        if (stickyTrigger <= 50) {
          experienceTitle.classList.add("sticky");
        } else {
          experienceTitle.classList.remove("sticky");
        }
      });
    </script>
    <script>
      // 1) 停用瀏覽器的自動卷軸還原
      if ("scrollRestoration" in history) {
        history.scrollRestoration = "manual";
      }
    
      // 2) 載入時，如果網址有 #hash，清掉並回到最上方
      window.addEventListener("load", () => {
        if (location.hash) {
          history.replaceState(null, "", location.pathname + location.search);
        }
        // 兩幀後再滾到頂，確保排版完成
        requestAnimationFrame(() => {
          requestAnimationFrame(() => window.scrollTo(0, 0));
        });
      });
    
      // 3) 攔截所有指向 #id 的連結，改用 JS 平滑捲動，且不改網址
      document.addEventListener("click", (e) => {
        const a = e.target.closest('a[href^="#"]');
        if (!a) return;
        const id = a.getAttribute("href");
        if (id.length <= 1) return; // 跳過 href="#" 之類
        const el = document.querySelector(id);
        if (!el) return;
        e.preventDefault();
        el.scrollIntoView({ behavior: "smooth", block: "start" });
        // 清掉 hash，避免重新整理又跳
        history.replaceState(null, "", location.pathname + location.search);
      });
    </script>
    <script>
      document.addEventListener('DOMContentLoaded', function () {
        const headers = document.querySelectorAll('.slide-text');
        if (!headers.length) return;

        const io = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            const el = entry.target;
            if (entry.isIntersecting) {
              el.classList.add('is-in');
              el.classList.remove('is-out');
            } else {
              el.classList.remove('is-in');
              el.classList.add('is-out');
            }
          });
        }, { threshold: 0.35 });

        headers.forEach(h => io.observe(h));

        // Exit animation when leaving page
        const leaveAll = () => headers.forEach(h => h.classList.add('leaving'));
        window.addEventListener('pagehide', leaveAll);
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'hidden') {
            leaveAll();
          }
        });
      });
    </script>
    <!-- Updated Three.js script with better error handling and debugging -->
    <script type="module">
      import * as THREE from 'three';

      class PointCloudEffect {
        constructor() {
          this.scene = null;
          this.camera = null;
          this.renderer = null;
          this.pointCloud = null;
          this.originalPositions = [];
          this.targetPositions = [];
          this.animationProgress = 0;
          this.isAnimating = false;
          this.animationStartTime = 0;
          this.isInitialized = false;
          this.animationId = null;
          
          console.log('[v0] Starting PointCloudEffect initialization');
          this.init();
          this.setupPageVisibilityHandling();
        }

        setupPageVisibilityHandling() {
          const cleanup = () => {
            console.log('[v0] Cleaning up WebGL resources on page unload');
            if (this.animationId) {
              cancelAnimationFrame(this.animationId);
            }
            if (this.pointCloud) {
              if (this.pointCloud.geometry) {
                this.pointCloud.geometry.dispose();
              }
              if (this.pointCloud.material) {
                this.pointCloud.material.dispose();
              }
              if (this.scene) {
                this.scene.remove(this.pointCloud);
              }
            }
            if (this.renderer) {
              this.renderer.dispose();
              this.renderer.forceContextLoss();
            }
          };

          // Only cleanup on actual page unload, not visibility change
          window.addEventListener('beforeunload', cleanup);
          window.addEventListener('pagehide', cleanup);
          
          document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
              console.log('[v0] Page became visible - resuming/reinitializing point cloud');
              if (!this.isInitialized || !this.renderer || this.renderer.getContext().isContextLost()) {
                this.reinitialize();
              } else {
                this.resumeAnimation();
              }
            } else {
              console.log('[v0] Page became hidden - pausing animation');
              this.pauseAnimation();
            }
          });

          const canvas = document.getElementById('hero-pointcloud');
          if (canvas) {
            canvas.addEventListener('webglcontextlost', (event) => {
              console.log('[v0] WebGL context lost');
              event.preventDefault();
              this.pauseAnimation();
            });

            canvas.addEventListener('webglcontextrestored', () => {
              console.log('[v0] WebGL context restored - reinitializing');
              this.reinitialize();
            });
          }
        }

        pauseAnimation() {
          if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
          }
        }

        resumeAnimation() {
          if (!this.animationId && this.isInitialized) {
            this.animate();
          }
        }

        reinitialize() {
          console.log('[v0] Reinitializing point cloud effect');
          this.isInitialized = false;
          
          // Clean up existing resources
          if (this.pointCloud && this.scene) {
            this.scene.remove(this.pointCloud);
          }
          
          // Reinitialize everything
          this.init();
        }

        init() {
          const canvas = document.getElementById('hero-pointcloud');
          if (!canvas) {
            console.error('[v0] Canvas element not found');
            return;
          }
          
          console.log('[v0] Canvas found, setting up Three.js scene');
          
          // Scene setup
          this.scene = new THREE.Scene();
          this.scene.background = null;
          
          // Camera setup - positioned closer to see the point cloud better
          this.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 1000);
          this.camera.position.set(0, 2, 8);
          this.camera.lookAt(0, 0, 0);
          
          // Renderer setup
          this.renderer = new THREE.WebGLRenderer({ 
            canvas: canvas, 
            antialias: true,
            alpha: true
          });
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          this.renderer.setClearColor(0x000000, 0);
          
          // Lighting
          const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
          this.scene.add(ambientLight);
          
          const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
          directionalLight1.position.set(5, 5, 5);
          this.scene.add(directionalLight1);
          
          console.log('[v0] Scene setup complete, loading BIN file');
          
          // Load BIN file
          this.loadBINFile();
          
          // Controls
          this.setupControls();
          
          // Resize handler
          window.addEventListener('resize', () => this.onWindowResize());
          
          // Start render loop immediately
          this.animate();
          
          this.isInitialized = true;
        }

        loadBINFile() {
          console.log('[v0] Attempting to load BIN file: ./linkou_1.bin');
          
          fetch('./linkou_1.bin')
            .then(response => {
              console.log('[v0] Fetch response status:', response.status, response.statusText);
              if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
              }
              return response.arrayBuffer();
            })
            .then(buffer => {
              console.log('[v0] BIN file loaded successfully, size:', buffer.byteLength, 'bytes');
              console.log('[v0] Expected points:', Math.floor(buffer.byteLength / 15), '(assuming 15 bytes per point)');
              this.parseBinaryPointCloud(buffer);
            })
            .catch(error => {
              console.warn('[v0] BIN load failed:', error);
              console.log('[v0] Creating fallback particle system');
              this.createFallbackParticles();
            });
        }

        parseBinaryPointCloud(buffer) {
          console.log('[v0] Parsing binary point cloud data with color');
          
          const pointSize = 15; // 12 bytes float + 3 bytes color
          const numPoints = Math.floor(buffer.byteLength / pointSize);
          
          console.log('[v0] Buffer size:', buffer.byteLength, 'bytes');
          console.log('[v0] Point size:', pointSize, 'bytes per point');
          console.log('[v0] Calculated particle count:', numPoints);
          
          if (numPoints === 0) {
            console.warn('[v0] No valid points found in binary data');
            this.createFallbackParticles();
            return;
          }
          
          const positions = new Float32Array(numPoints * 3);
          const colors = new Float32Array(numPoints * 3); // normalized [0,1]
          const dv = new DataView(buffer);
          
          for (let i = 0; i < numPoints; i++) {
            const offset = i * pointSize;
            
            // Read XYZ coordinates as float32 (little-endian)
            const x = dv.getFloat32(offset, true);
            const y = dv.getFloat32(offset + 4, true);
            const z = dv.getFloat32(offset + 8, true);
            
            // Read RGB color as uint8
            const r = dv.getUint8(offset + 12);
            const g = dv.getUint8(offset + 13);
            const b = dv.getUint8(offset + 14);
            
            // Store positions
            positions.set([x, y, z], i * 3);
            
            // Store normalized colors [0,1]
            colors.set([r / 255, g / 255, b / 255], i * 3);
          }
          
          console.log('[v0] First few positions:', positions.slice(0, 9));
          console.log('[v0] First few colors:', colors.slice(0, 9));
          
          // Create geometry with both position and color attributes
          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
          
          console.log('[v0] Geometry created with', numPoints, 'points and color data');
          this.createParticleSystem(geometry);
        }

        createParticleSystem(geometry) {
          console.log('[v0] Creating particle system from binary geometry');
          
          const material = new THREE.PointsMaterial({
            size: 0.02,
            vertexColors: true, // Use colors from geometry
            transparent: true,
            opacity: 0.8,
            sizeAttenuation: true,
          });

          // Center and scale the geometry BEFORE creating the point cloud
          geometry.computeBoundingBox();
          const box = geometry.boundingBox;
          console.log('[v0] Original bounding box:', box);
          
          const center = new THREE.Vector3();
          box.getCenter(center);
          console.log('[v0] Geometry center:', center);

          // Translate geometry to center
          geometry.translate(-center.x, -center.y, -center.z);

          const size = new THREE.Vector3();
          box.getSize(size);
          const maxDim = Math.max(size.x, size.y, size.z);
          const scale = 6 / maxDim; // Increased from 3 to 6 for larger final model
          console.log('[v0] Applying scale:', scale);
          geometry.scale(scale, scale, scale);

          // Store target positions AFTER transformations
          const positions = geometry.attributes.position.array;
          const particleCount = positions.length / 3;
          
          this.targetPositions = [];
          for (let i = 0; i < particleCount; i++) {
            const x = positions[i * 3];
            const y = positions[i * 3 + 1];
            const z = positions[i * 3 + 2];
            
            this.targetPositions.push(
              x,
              z,
              y
            );
          }
          
          this.originalPositions = [];
          for (let i = 0; i < particleCount; i++) {
            const radius = 8 + Math.random() * 4; // Reduced from 15-25 to 8-12
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            
            this.originalPositions.push(
              radius * Math.sin(phi) * Math.cos(theta),
              radius * Math.sin(phi) * Math.sin(theta),
              radius * Math.cos(phi)
            );
          }
          
          // Set initial spread positions
          geometry.setAttribute('position', new THREE.Float32BufferAttribute(this.originalPositions, 3));
          
          this.pointCloud = new THREE.Points(geometry, material);
          this.scene.add(this.pointCloud);
          
          console.log('[v0] Point cloud created and added to scene with', particleCount, 'particles');
          console.log('[v0] Starting animation immediately');
          
          this.startAnimation();
        }

        createFallbackParticles() {
          console.log('[v0] Creating fallback particle system with 2000 points');
          const particleCount = 2000;
          
          this.targetPositions = [];
          for (let i = 0; i < particleCount; i++) {
            const radius = 3 + Math.random() * 1; // Increased from 1.5-2 to 3-4
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            
            this.targetPositions.push(
              radius * Math.sin(phi) * Math.cos(theta),
              radius * Math.sin(phi) * Math.sin(theta),
              radius * Math.cos(phi)
            );
          }
          
          this.originalPositions = [];
          for (let i = 0; i < particleCount; i++) {
            const radius = 8 + Math.random() * 4; // Reduced from 15-25 to 8-12
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            
            this.originalPositions.push(
              radius * Math.sin(phi) * Math.cos(theta),
              radius * Math.sin(phi) * Math.sin(theta),
              radius * Math.cos(phi)
            );
          }
          
          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.Float32BufferAttribute(this.originalPositions, 3));
          
          const material = new THREE.PointsMaterial({
            color: 0x00ffff,
            size: 0.05,
            sizeAttenuation: true,
            transparent: true,
            opacity: 0.8
          });
          
          this.pointCloud = new THREE.Points(geometry, material);
          this.scene.add(this.pointCloud);
          
          console.log('[v0] Fallback particles created and added to scene');
          
          this.startAnimation();
        }

        startAnimation() {
          this.isAnimating = true;
          this.animationStartTime = Date.now();
          console.log('[v0] Starting point cloud gathering animation');
        }

        setupControls() {
          let mouseX = 0, mouseY = 0;
          let targetRotationX = 0, targetRotationY = 0;
          
          document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX - window.innerWidth / 2) / window.innerWidth;
            mouseY = (event.clientY - window.innerHeight / 2) / window.innerHeight;
            
            targetRotationX = mouseY * 0.1;
            targetRotationY = mouseX * 0.1;
          });
          
          const updateRotation = () => {
            if (this.pointCloud) {
              this.pointCloud.rotation.x += (targetRotationX - this.pointCloud.rotation.x) * 0.02;
              this.pointCloud.rotation.y += (targetRotationY - this.pointCloud.rotation.y) * 0.02;
            }
            requestAnimationFrame(updateRotation);
          };
          updateRotation();
        }

        animate() {
          this.animationId = requestAnimationFrame(() => this.animate());
          
          if (this.isAnimating && this.pointCloud) {
            const elapsed = Date.now() - this.animationStartTime;
            const duration = 10000; // 10 seconds
            this.animationProgress = Math.min(elapsed / duration, 1);
            
            const easeOut = 1 - Math.pow(1 - this.animationProgress, 4);
            
            const currentPositions = [];
            for (let i = 0; i < this.originalPositions.length; i++) {
              currentPositions[i] = this.originalPositions[i] + 
                (this.targetPositions[i] - this.originalPositions[i]) * easeOut;
            }
            
            this.pointCloud.geometry.setAttribute('position', 
              new THREE.Float32BufferAttribute(currentPositions, 3));
            this.pointCloud.geometry.attributes.position.needsUpdate = true;
            
            if (this.animationProgress >= 1) {
              this.isAnimating = false;
              console.log('[v0] Point cloud animation complete');
            }
          }
          
          // Gentle auto-rotation when not animating
          if (!this.isAnimating && this.pointCloud) {
            this.pointCloud.rotation.y += 0.002;
          }
          
          this.renderer.render(this.scene, this.camera);
        }

        onWindowResize() {
          this.camera.aspect = window.innerWidth / window.innerHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(window.innerWidth, window.innerHeight);
        }
      }

      // Initialize when DOM is ready
      document.addEventListener('DOMContentLoaded', () => {
        console.log('[v0] DOM loaded, initializing point cloud effect');
        try {
          new PointCloudEffect();
        } catch (error) {
          console.error('[v0] Failed to initialize point cloud:', error);
        }
      });
    </script>
  </body>
</html>
